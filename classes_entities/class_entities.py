import pyinputplus as pyip
###############################################################################
#  Entity is the Base Class from which all "People" are Inherited in Usurper. #
###############################################################################
class Entity:
    # Entity Attributes
    def __init__(self, name, grid_location, team, traits, speed_overland, spells_known, skills_known, abilities_learned):
        self.name = name
        # Generally grid locations are those which have been generated by the
        # game map (meaning limited to that set.)
        # When creating the game map, a "dead" grid needs to be created,
        # in order to "store" entities which don't stay on normal map locations.
        # example: Legendary Monsters.
        self.grid_location = grid_location
        # This concept is a little abstract, and teams will be classes that
        # deal with Players and Non-Player Characters (NPC)s alike.
        # Generally, there will be three types of Teams:
        ## A Player Team "TeamPlayer1",
        ## a Team-NPC (such as a Noble House, which occupy the Cities.),
        ## Non-Team-NPC (such as a random hostile encounter in Grid A1.)
        self.team = team
        self.traits = traits
        self.speed_overland = speed_overland
        self.spells_known = spells_known
        self.skills_known = skills_known
        self.abilities_learned = abilities_learned

    # Entity Methods.
    def change_grid_location(self, target_grid_location):
        '''
        Should be called by making the new grid location as the "X = func()"
        call.
        Is NOT used for giving orders to an entity.
        Is used for a permanent changed to an entity (such as moving from one
        lair to another.)
        '''
        self.grid_location = target_grid_location
        return self.grid_location

    def check_can_reach_grid(self, grid_location, target_grid_location):
        '''
        Should be called whenever an order is assigned to an entity.
        Should be used to determine if an entity can reach that grid.
        Compares overland speed to the grid location and the target grid
        location.
        Should be called in the background.
        Consideration: Should this be done and then POSSIBLE grids be
        highlighted on the map?  Or just give the player a "you can't do that"
        response when they try to click an inappropriate grid?
        Consideration: how to assess for letters?  Translate all letters to numeric value?
        '''
        # order NUMERIC of grid_location compared to target_grid_location
        # subtract one from the other.
        # determine if that is equal to or less than the speed_overland stat.
        ## if yes - continue to next segment.
        ## if no - give player error and do not allow.
        # order ALPHA of grid_location compared to target_grid_location
        # subtract one from the other.
        # determine if that is equal to or less than the speed_overland stat.
        ## if yes - order is allowed.
        ## if no - give player error and do not allow.

    def display_possible_actions(self, available_actions):
        '''
        Should be called within the context of the ORDERS Menu.
        Called whenever a player selects a given entity,
        displays the available actions (orders) options for that entity.
        '''
        for x in available_actions:
            print(x)
        return None

    def change_name(self, name):
        '''
        Players may want to change the default names of their new squads and the like.
        Should be called in the context of the LAIR Menu.
        Whenever a player selects a given entity, one of the button options
        should be to call the Change Name function
        Called whenever a player selects a given entity and selects to
        Change Name.
        '''
        self.name = pyip.inputStr(prompt=("Change {}'s name to what? ").format(name), blank=False)
        # is this necessary? or just none?
        return self.name

    def display_name(self):
        print("Name: {}".format(self.name))

    def set_team(self, team):
        '''
        Should be called in the background whenever an entity is initially created.
        This will be used to establish into which lair/collective the newly generated
        entity will be assigned.
        Should be called actively (visible to the affected players) if an entity is captured via the Prison and/or Force Cage mechanics.
        '''
        # I don't know how to make this method, yet.
        # will need the following:
        ## Check: Player, Team-NPC, or Generic-NPC.
        ## Assign self.team to the given Check.
        pass

    def learn_spell(self, spells_known, spell_choice):
        '''
        Several situations arise where entities either begin with spells, or may have the opportunity to learn them.  This simply adds those spells to the spell list.
        The most important thing is the "if already exists" check.
        If a spell already exists on a list, it cannot be added again.
        '''
        if spell_choice in self.spells_known:
            print("This spell is already known.  Select a different spell.")
            # Currently "spells" is not defined.  Will need to import some sort of "global collections"
            # Module that has the list of game spells to make this function properly.
            spell_choice = pyip.inputMenu(spells, prompt="select a spell to learn. ", numbered=True, blank=True)
            self.learn_spell(spells_known, spell_choice)
        else:
            self.spells_known.append(spell_choice)
        return print("{} knows the following spells: {}".format(self.name, self.spells_known))

    def forget_spell(self, spells_known):
        '''
        Significantly less common than learning a new spell, sometimes a
        player will have an opportunity to sacrifice a known spell to gain
        a greater power or ability.
        This simply lets the player see a list of known spells on the entity,
        select one, and it is removed from the list of known spells.
        '''
        forget_spellchoice = pyip.inputMenu(spells_known, promp="select which spell to forget. ", numbered=True, blank=False)
        self.spells_known.remove(forget_spellchoice)
        return print("{} has forgotten the following spell: {}.".format(self.name, forget_spellchoice))

    def learn_skill(self):
        '''
        Checking XP.  Calculations?
        Assume everything exists but it as "0", and only display above that?
        Or actually only exist at "1+"?
        More contemplation to be done here.
        '''
        pass

    def forget_skill(self):
        pass

    def gain_skill_experience(self):
        '''
        Should be used to decide WHICH entity gets skill XP.
        Skill XP is generally generated if a squad is present during a successful action.  Other situations may result in generating skill XP.
        Only used to determine eligibility (must have been present in action) and then grant that amount.
        The amount granted should be fed into the "learn skill" function.
        '''
        pass
